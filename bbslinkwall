/**************************************************************************\
$VER: BBSLinkWall, v2.0.1 (Sep-11-2019) by k1ds3ns4t10n of -X-caliber BBS
\**************************************************************************/
options results;signal on SYNTAX;signal on ERROR;signal on IOERR
a=sourceline(2);parse var a . " " title ", " ver " (" vdate ") by " author " " .
tr=transmit;se=sendstring;gc=getchar;gu=getuser;gs=getscratch;mg=maygetchar
bbsidentify bbs;cv=left(word(result,3),4);cnet4=(datatype(cv,"n")=1&cv>"4.25")
bbsidentify name;g.bbsName=strip(result, 'B');esc="1b5b"x;cty="19"x;ctq="11"x
rs="rexxsupport.library";if ~show("l",rs) then if ~addlib(rs,0,-30) then exit
parse source . . fp .; df=left(fp,max(lastpos('/',fp),lastpos(':',fp)))
changewhere "BBSLink Wall"
/**************************************************************************/
/*                                                                        */
/*  C-Net BBSLink Wall                           -X-caliber BBS           */
/*    Used to seamlessly connect a C-Net            bbs.aholix.net:6800   */
/*    Amiga BBS to the BBSLink.net                                        */
/*    networked Graffiti Wall.                                            */
/*                                                                        */
/*  Changelog:                                                            */
/*    v2.0.1 (          ) by k1ds3ns4t10n of -X-caliber BBS               */
/*     - Code cleanup and refactor                                        */
/*     - Renamed g.logErrors switch to g.debug                            */
/*     - Added g.defaultResponse and g.showCustomHeader switches          */
/*     - Added custom header files                                        */
/*     - Added URL encoding                                               */
/*                                                                        */
/*    v2.0.0 (4 Sep 2019) by k1ds3ns4t10n of -X-caliber BBS               */
/*     - Replaced httpj with http_get to resolve stability issues with    */
/*       the BBS locking up when posting.                                 */
/*     - Resolved issue with token expiring before user typed in their    */
/*       wall post.                                                       */
/*     - Added showStatus, autoRetry, and logErrors as Sysop              */
/*       configurable switches                                            */
/*                                                                        */
/*    v1.0.0 (3 Feb 2018) by Link of CheckSum Acknowledged BBS            */
/*     - Orignal version                                                  */
/*                                                                        */
/*  CheckSum Acknowledged BBS has gone offline as of: 15 Jul 2019 :(      */
/*                                                                        */
/*  Use at your own risk.                                                 */
/*                                                                        */
/*  INSTALATION INSTRUCTIONS:                                             */
/*                                                                        */
/*  1) Create a folder called 'bbslink' in your PFiles: directory.        */
/*     Copy this file and the *.wallHeader files there.                   */
/*                                                                        */
/*  2) Download http_get from Aminet and install in C:                    */
/*     https://aminet.net/package/comm/tcp/http_get                       */
/*                                                                        */
/*  3) Register on bbslink.net as a sysop.  If you have already done      */
/*     so when you registered for the door game server, you will need     */
/*     to use the information you got from that time you registered.      */
/*                                                                        */
/*  4) You will receive an email from them with your System Code,         */
/*     Authorization Code, and Scheme Code. Copy and paste these values   */
/*     from that email down below where indicated in SysOp Configuralble  */
/*     Options.                                                           */
/*                                                                        */
/*  5) Optional: There are several options you may change based on your   */
/*     needs in the SysOp Configurable Options block below.               */
/*                                                                        */
/*  6) Add this file as an Arexx executable anywhere on your system using */
/*     the path:                                                          */
/*                                                                        */
/*     pfiles:bbslink/bbslinkwall                                         */
/*                                                                        */
/*  7) That's it!                                                         */
/*                                                                        */
/**************************************************************************/
/* SysOp Configurable Options *********************************************/

/* Enter information from the email you received here */
b.SystemCode       = "yourcodehere" /* <--Enter your System Code */
b.AuthorizationCode= "yourcodehere" /* <--Enter your Authorization Code */
b.SchemeCode       = "yourcodehere" /* <--Enter your Scheme Code */

/* This path should be created manually when installing */
g.pfilePath        = "PFILES:bbslink/" /* must end with a trailing slash */

/* This path will be created automatically as needed */
g.tempPath         = "RAM:BBSLINK/"    /* must end with a trailing slash */

/* The "sys" in the below filename will be automatically replaced by the users
   chosen terminal type (tt1, tt2, tt3 or tt4), so do not hard set a terminal
   type here. Additionally, if the users term width is less than 80, then a 40
   column header file will be searched for by appending "40" to the end of this
   filename. */
g.wallHeaderFile   = g.pfilePath||"sys.wallHeader"

/* These swtiches control how the Wall functions */
g.defaultResponse  = 0  /* Set default response to the "Write on Wall" prompt.
                           0 = No, 1 = Yes */
g.showCustomHeader = 1  /* Show custom header when displaying the wall based on
                           the users chosen terminal type. The custom header
                           file should display no more than 7 lines max.
                           Setting this to off will display the default BBSLink
                           ANSI header to all users.
                           0 = Off, 1 = On */
g.showStatus       = 1  /* Show http type status messages to the user.
                           0 = Off, 1 = On */
g.autoRetry        = 1  /* Auto-retry web request if it times out or returns
                           a blank result. User may cancel the request by
                           pressing the ESC key.
                           0 = Off, 1 = On */
g.debug            = 0  /* Show Errors to the SysOp's (account 1) screen.
                           This is for debug purposes and should not be left
                           on during normal operations.
                           0 = Off, 1 = On */

/* Ok to change these as needed for your system */
g.timeout          = 20 /* API http request timeout in seconds */

/* Ok to change these messages, feel free to add ANSI or MCI codes. */
s.retrieving       = "Retrieving Data"
s.sending          = "Sending Data"
s.reqTimedOut      = "Request timed out, please try again later."
s.cancelled        = "Request Cancelled"
s.escToCancel      = "(ESC to cancel)"
s.anyKey           = "Smash any key to continue.."

/* End of SysOp Configurable Options **************************************/
/**************************************************************************/

c.err  = esc"0;31m"
c.blink= esc"5m"
c.reset= esc"0m"

if ~exists(g.tempPath) then address command'makedir 'strip(g.tempPath,"T","/")

gu 40; g.uid = space(result ,0)  /* account id */
gu 27; g.maxCol=result-1         /* term width */
gu 28; g.termType=result         /* term type  */
g.debug = g.debug&g.uid==1

if ~exists("c:http_get") then signal badHttp

/* Show the wall! */
se esc"0;36m"
call getWall

/* Ask user if they want to write to the wall themselves */
if g.defaultResponse then prompt 5 YESNO "Write on the wall [Y,n]? "
else prompt 5 NOYES "Write on the wall [y,N]? "

/* If they answered no, quit. */
if result=='No' then exit
else call check

/* Find out if user already has a registered user name */
tr "  Looking for your pen - it's around here somewhere..."

b.key=randomString()
b.ktoken=getToken(b.key)
b.username=sendToServer("username",'')

/* Check for username error and display as appropriate */
if (substr(b.username, 1, 3) = "*xx") then do
  tr "  Sorry, I looked everywhere. Can't find it. Oh, and this happened:  "substr(b.username, 3)
  signal EXIT
end
else if (b.username = "*notexist") then do
  /* Not registered */
  se "  So you're new here! "
  do forever
    se "Choose a name (max 12 characters):"
    receive
    getnewusername=result
    if upper(result)="Q" then exit
    else call check
    b.key=randomString()
    b.ktoken=getToken(b.key)
    nuresult = sendToServer("newuser", getnewusername)
    if (nuresult = "*created") then do
      tr "  Welcome to the wall, " || getnewusername
      leave
    end
    else if (nuresult = "*inuse") then do
      tr "  That user name is already in use, choose another!"
    end
    else if (nuresult = "*inval") then do
      tr "  That user name is invalid, choose another!"
    end
  end

  /* Even if they didn't before, they should have a user name now. If they still
   don't for some reason, show an error and quit. This will also catch
   authentication errors. */

  b.username = sendToServer("username",'')
  if (substr(b.username, 1, 1) = '*') then do
    tr "  Sorry, I can't find it :-(    (An error occurred ["b.username"])"
    signal EXIT
  end
end

/* Get the user's thoughts - in 64 characters or less! */
tr "  What's on your mind, "b.username"?  (max 64 characters)"
se ":"

/* Take the wall post */
prompt 64 NORMAL ""
newPost=result
if upper(result)=="Q" then exit
else call check


/* If input is more than 2 characters, submit it */
if length(newPost) > 2 then do
  b.key=randomString()
  b.ktoken=getToken(b.key)
  postresult = sendToServer("post", newPost)
  /* Check result of post attempt */
  if (postresult = "*post") then do
    /* Successful */
    tr "  Post successful!"
    /* Show the wall! */
    call getWall
    tr
  end
  else if (postresult = "*int") then do
    /* Last post < 10 minutes ago */
    se "  Sorry, you have to wait 10 minutes between posts. "
  end
  else if (postresult = "*inval") then do
    /* Post contained > 64 characters */
    se "  Your post contained too many characters (max length 64 chars)."
  end
  else do
    /* Post failed, unknown reason */
    tr "post result: "postresult
    se "  Post failed :-( "
  end
end
else do
  se "  Your post was too short! "
end

EXIT:
  se s.anyKey
  gc
  tr
  exit

/* Procedures *************************************************************/

/* Delete the results file */
deleteFile: procedure expose tr g.
  parse arg filename

  filePath= g.tempPath||filename

  if exists(filePath) then do
    do delLoop = 1 to 3
      if delete(filepath) then leave delLoop
      call delay(25)
    end
    if g.debug & exists(filePath) then tr 'BBSLINKWALL: Unable to delete 'filePath' after 'delLoop' tries.'
  end
return

/* fetches web request
   @param uri       the url to retrieve
   @param fileName  the filename where to store results
   @param type      0=retrieve, 1=send

   returns results as an array called resultsArr structured as:
     resultArr.0 = line count
     resultArr.1 = line 1 string
     resultArr.2 = line 2 string
      .
      .
      .
     resultArr.n = line n string
*/
fetchWebRequest: procedure expose se tr mg esc ver s. g. resultArr.
  parse arg uri, fileName, type

  filePath=g.tempPath||fileName
  userAgent= "http_get/1.0 (AmigaOS 3.1; Amiga; 680x0; ks:40.68; wb:40.42) CNet/5 BBSLinkWall/"strip(ver,'L','v')" ("g.bbsName")"

  /* run through outer loop at least once, repeat the loop if g.autoRetry is
     enabled and line count in resultArr.0 == 0 */

  do until ~g.autoRetry | resultArr.0>0
    /* clear any previous data in resultArr */
    drop resultArr.

    /* init resultArr */
    resultArr.0=0
    resultArr.1=""

    /* make web request */
    httpcmd = 'run >nil: http_get -u "'userAgent'" "'uri'" >'filePath
    address command httpcmd

    call time('r')

    /* show status message */
    if g.showStatus then do
      if type then reqType=s.sending
      else reqType=s.retrieving
      dotCount=0
      se reqType
    end

    /* inner loop checks if the results file is ready and exits if the
       file is ready or the timeout period has been reached */

    bufferflush
    do until time('e') > g.timeout + 1
      mg
      if result=="NOCHAR" then nop
      else if C2D(result)==27 then do
        /* ESC key will exit */
        resultArr.0 = 1
        resultArr.1 = s.cancelled
        leave /* cause loop to exit */
      end
      else call check

      call delay(25) /* 1/2 second */

      /* check if results file is ready yet */
      if exists(filePath) then do
        if open(BLW, filePath, R) then do
          /* read results file into resultsArr */
          line=0
          do while ~eof(BLW)
            line=line+1
            resultArr.line = readln(BLW)
          end
          /* place line count at resultArr.0 */
          resultArr.0 = line
          call close(BLW)
          leave /* cause loop to exit */
        end
        else if g.debug then tr "BBSLINKWALL: "filePath" exists but could not open"
      end
      else if g.debug then tr "BBSLINKWALL: "filePath" does not exist, could not open"

      /* update status message */
      if g.showStatus then do
        if dotCount==0 then se " "s.escToCancel
        else se "."
        dotCount = dotCount + 1
      end
    end
    bufferflush

    /* clear status message */
    if g.showStatus then do
      CR = "0d"x
      statusLen = length(reqType) + length(s.escToCancel) + dotCount + 1
      se CR||copies(' ', statusLen)||CR
    end
  end

  /* check if request timed out */
  if resultArr.0==0 then do
    resultArr.0=1
    reslutArr.1=s.reqTimedOut
  end
return

/* Show the wall! */
getWall: procedure expose se tr mg esc ver ctq s. g. resultArr.
  filename= "wall"g.uid

  /* Delete the last results file in case it wasn't deleted last time */
  call deleteFile(filename)

  /* Fetch the wall from BBSLink */
  uri="http://games.bbslink.net/wall.php?action=show"
  call fetchWebRequest(uri, filename, 0)

  /* display wall */
  if resultArr.0 > 0 then do
    cls
    if g.maxCol >= 79 then se ctq"@4}" /* disable more */

    if g.showCustomHeader then do
      /* get name of header file based on term type and term width */
      header = replace(g.wallHeaderFile, "sys.", "tt"g.termType".")  /* ttX.wallHeader   */
      if g.maxCol < 79 & exists(header"40") then header = header"40" /* ttX.wallHeader40 */
      else if g.maxCol < 79 & exists(g.wallHeaderFile"40") then
        header = g.wallHeaderFile"40"                                /* sys.wallHeader40 */
      else if ~exists(header) then header = g.wallHeaderFile         /* sys.wallHeader   */
    end

    if g.showCustomHeader & exists(header) then do
      /* g.showCustomHeader is enabled and file found, show custom header */
      call mySendFile(header)
    end
    else do
      /* g.showCustomHeader is disabled or file not found, show default header */
      do i=1 to 7
        tr resultArr.i
      end
    end

    /* show remaining portion of the wall */
    do i=8 to resultArr.0
      tr resultArr.i
      checkabort
      if result == 1 then do
        tr
        leave
      end
    end
  end

  se esc"0;36m"

  /* Delete the results file */
  call deleteFile(filename)
return

/* Send data to the server */
sendToServer: procedure expose se tr mg esc ver b. s. g. resultArr.
  parse arg action, data

  filename= "post"g.uid

  /* Assemble the Authentication Request URL */
  xAction ='action='action
  xKey    ='&key='b.key
  xUser   ='&user='g.uid
  xSystem ='&system='b.SystemCode
  xAuth   ='&auth='MD5(b.AuthorizationCode || b.ktoken)
  xCode   ='&scheme='MD5(b.SchemeCode || b.ktoken)
  xToken  ='&token='b.ktoken
  xType   ='&type=amiga'
  xVersion='&version=1.0.0' /* TODO: update version */

  /* URL encode the user input string */
  encodedData = urlEncode(data)

  uri = 'http://games.bbslink.net/wall.php?'xAction||xKey||xUser||xSystem||xAuth||xCode||xToken||xType||xVersion
  if length(data) > 0 then uri=uri'&data='encodedData

  /* Delete the last results file in case it wasn't deleted last time */
  call deleteFile(filename)

  /* Fetch the authorization request */
  call fetchWebRequest(uri, filename, 1)

  /* pull out results from resultArr */
  body=''
  if resultArr.0 > 0 then do
    do i=1 to resultArr.0
      body=resultArr.i
    end
  end
  else if g.debug then tr 'BBSLINKWALL: Unable to display results. Web request likely failed.'

  /* Delete the results file */
  call deleteFile(filename)
return body

/* Retrieve a token from the server */
getToken: procedure expose se tr mg esc ver s. g. resultArr.
  parse arg key

  filename= "token"g.uid

  /* Delete the last results file in case it wasn't deleted last time */
  call deleteFile(filename)

  /* Fetch the token from BBSLink */
  uri='http://games.bbslink.net/token.php?key='key
  call fetchWebRequest(uri, filename, 0)

  /* pull out token from resultArr */
  b.ktoken=''
  if resultArr.0 > 0 then do
    do i=1 to resultArr.0
      data= resultArr.i
      if data ~= '' then b.ktoken=data
    end
  end
  else do
    tr 'Unable to open token file. Exiting.'
    exit
  end

  /* Delete the results file */
  call deleteFile(filename)
return b.ktoken

/* replace - replace srch text with repl text in text
      ->replace("astrologer","log","nom")
      astronomer

   Source: Using Arexx on the Amiga, page 313
*/
replace: procedure
  parse arg text, srch, repl
  if index(text, srch)==0 then return text

  slen = length(srch)
  tlen = length(text)
  do until tlen = 0
    tlen = lastpos(srch, text, tlen)
    if tlen ~= 0 then do
      text = insert(repl, delstr(text,tlen,slen), tlen - 1)
      tlen = tlen - 1
    end
  end
return text

/* word wraps an input string at a given width and will not split any words
   @param text  the input string to word wrap
   @param width the width to wrap at

   results will be placed into an array called resultsArr structured as:
     resultArr.0 = line count
     resultArr.1 = line 1 string
     resultArr.2 = line 2 string
      .
      .
      .
     resultArr.n = line n string
*/
wordWrap: procedure expose resultArr.
  parse arg text, width

  /* clear any previous data in the results array */
  drop resultArr.

  /* line count is held at position 0, init it to line 1 */
  resultArr.0 = 1

  if length(text) <= width then do
    resultArr.1 = text
    return
  end

  line = resultArr.0
  resultArr.1 = ""
  do while text ~= ""
    parse var text word text

    /* check if current line + next word < width */
    if length(resultArr.line) + length(word) + 1 <= width then do
      /* add word to current line */
      if resultArr.line=="" then resultArr.line = word
      else resultArr.line = resultArr.line" "word
    end
    else do
      /* start new line with with next word */
      line = line + 1
      resultArr.line = word
    end
  end

  /* store final line count at position 0 of the array */
  resultArr.0 = line
return

mySendFile: procedure expose tr
  parse arg filePath

  if open(BLWF, filePath, R) then do
    do while ~eof(BLWF)
      tr readln(BLWF)
      checkabort
      if result == 1 then do
        tr
        leave
      end
    end
    call close(BLWF)
  end
return

/* https://www.cgisecurity.com/lib/URLEmbeddedAttacks.html                */
/*                                                                        */
/* The standard (rfc2396) defines the following classes of characters:    */
/* Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' ( )                          */
/*   Reserved: ; / ? : @ & = + $ ,                                        */
/*                                                                        */
/* The standard (rfc2396) defines the following groupings of characters   */
/* that must be escaped to be included within a URI:                      */
/*                                                                        */
/* Control: <US-ASCII coded characters 00-1F and 7F hexadecimal>          */
/*   Space: <US-ASCII coded character 20 hexadecimal>                     */
/*  Delims: < > # % "                                                     */
/*  Unwise: { } | \ ^ [ ] `                                               */
/*                                                                        */
/* more info:                                                             */
/*  https://www.url-encode-decode.com/                                    */
/*  https://www.w3schools.com/tags/ref_urlencode.asp                      */

urlEncode: procedure expose tr
  parse arg inputString

  encodedString = inputString

  call getUrlEncodeTable
  do i=0 to urlEncode.max
    encodedString = replace(encodedString, urlEncode.in.i, urlEncode.out.i)
  end
  encodedString=space(encodedString, 1, "+")
return encodedString

getUrlEncodeTable:
  /* Delim characters */
  urlEncode.in.0="%";    urlEncode.out.0="%25"
  urlEncode.in.1='"';    urlEncode.out.1="%22"
  urlEncode.in.2="#";    urlEncode.out.2="%23"
  urlEncode.in.3="<";    urlEncode.out.3="%3C"
  urlEncode.in.4=">";    urlEncode.out.4="%3E"

  /* Reserved characters */
  urlEncode.in.5="$";    urlEncode.out.5="%24"
  urlEncode.in.6="&";    urlEncode.out.6="%26"
  urlEncode.in.7="+";    urlEncode.out.7="%2B"
  urlEncode.in.8=",";    urlEncode.out.8="%2C"
  urlEncode.in.9="/";    urlEncode.out.9="%2F"
  urlEncode.in.10=":";   urlEncode.out.10="%3A"
  urlEncode.in.11=";";   urlEncode.out.11="%3B"
  urlEncode.in.12="=";   urlEncode.out.12="%3D"
  urlEncode.in.13="?";   urlEncode.out.13="%3F"
  urlEncode.in.14="@";   urlEncode.out.14="%40"

  /* Unwise characters */
  urlEncode.in.15="[";   urlEncode.out.15="%5B"
  urlEncode.in.16="\";   urlEncode.out.16="%5C"
  urlEncode.in.17="]";   urlEncode.out.17="%5D"
  urlEncode.in.18="^";   urlEncode.out.18="%5E"
  urlEncode.in.19="`";   urlEncode.out.19="%60"
  urlEncode.in.20="{";   urlEncode.out.20="%7B"
  urlEncode.in.21="|";   urlEncode.out.21="%7C"
  urlEncode.in.22="}";   urlEncode.out.22="%7D"

  /* ASCII control characters */
  urlEncode.in.23="00"x; urlEncode.out.23="%00" /* NUL null character         */
  urlEncode.in.24="01"x; urlEncode.out.24="%01" /* SOH start of header        */
  urlEncode.in.25="02"x; urlEncode.out.25="%02" /* STX start of text          */
  urlEncode.in.26="03"x; urlEncode.out.26="%03" /* ETX end of text            */
  urlEncode.in.27="04"x; urlEncode.out.27="%04" /* EOT end of transmission    */
  urlEncode.in.28="05"x; urlEncode.out.28="%05" /* ENQ enquiry                */
  urlEncode.in.29="06"x; urlEncode.out.29="%06" /* ACK acknowledge            */
  urlEncode.in.30="07"x; urlEncode.out.30="%07" /* BEL bell (ring)            */
  urlEncode.in.31="08"x; urlEncode.out.31="%08" /* BS  backspace              */
  urlEncode.in.32="09"x; urlEncode.out.32="%09" /* HT  horizontal tab         */
  urlEncode.in.33="0a"x; urlEncode.out.33="%0A" /* LF  line feed              */
  urlEncode.in.34="0b"x; urlEncode.out.34="%0B" /* VT  vertical tab           */
  urlEncode.in.35="0c"x; urlEncode.out.35="%0C" /* FF  form feed              */
  urlEncode.in.36="0d"x; urlEncode.out.36="%0D" /* CR  carriage return        */
  urlEncode.in.37="0e"x; urlEncode.out.37="%0E" /* SO  shift out              */
  urlEncode.in.38="0f"x; urlEncode.out.38="%0F" /* SI  shift in               */
  urlEncode.in.39="10"x; urlEncode.out.39="%10" /* DLE data link escape       */
  urlEncode.in.40="11"x; urlEncode.out.40="%11" /* DC1 device control 1       */
  urlEncode.in.41="12"x; urlEncode.out.41="%12" /* DC2 device control 2       */
  urlEncode.in.42="13"x; urlEncode.out.42="%13" /* DC3 device control 3       */
  urlEncode.in.43="14"x; urlEncode.out.43="%14" /* DC4 device control 4       */
  urlEncode.in.44="15"x; urlEncode.out.44="%15" /* NAK negative acknowledge   */
  urlEncode.in.45="16"x; urlEncode.out.45="%16" /* SYN synchronize            */
  urlEncode.in.46="17"x; urlEncode.out.46="%17" /* ETB end transmission block */
  urlEncode.in.47="18"x; urlEncode.out.47="%18" /* CAN cancel                 */
  urlEncode.in.48="19"x; urlEncode.out.48="%19" /* EM  end of medium          */
  urlEncode.in.49="1a"x; urlEncode.out.49="%1A" /* SUB substitute             */
  urlEncode.in.50="1b"x; urlEncode.out.50="%1B" /* ESC escape                 */
  urlEncode.in.51="1c"x; urlEncode.out.51="%1C" /* FS  file separator         */
  urlEncode.in.52="1d"x; urlEncode.out.52="%1D" /* GS  group separator        */
  urlEncode.in.53="1e"x; urlEncode.out.53="%1E" /* RS  record separator       */
  urlEncode.in.54="1f"x; urlEncode.out.54="%1F" /* US  unit separator         */
  urlEncode.in.55="7f"x; urlEncode.out.55="%7F" /* Delete                     */

  urlEncode.max=55
return

guruError: procedure expose tr se gc c. g.
  parse arg errMsg1, errMsg2
  cls
  tr c.err

  tr c.blink"Û"copies('ß', g.maxCol-2)"Û"

  call wordWrap(errMsg1, g.maxCol-4)
  do i=1 to resultArr.0
    tr c.blink"Û "c.reset||c.err|| center(resultArr.i, g.maxCol-4)||c.blink" Û"
  end

  call wordWrap(errMsg2, g.maxCol-4)
  do i=1 to resultArr.0
    tr c.blink"Û "c.reset||c.err|| center(resultArr.i, g.maxCol-4)||c.blink" Û"
  end

  tr c.blink"Û"copies('Ü', g.maxCol-2)"Û"c.reset
  tr
  se c.err||center("Press ANY KEY to continue..", g.maxCol)
  gc
return

badHttp:
  errMsg1 = "Could not find http_get! Please re-read the install instructions."
  errMsg2 = "Guru Meditation #00000000:084DH77F"
  call guruError(errMsg1, errMsg2)
  exit

/* This function makes a MD5 digest checksum from a given string */
/*                                                               */
/* ARexxMD5.rexx by AmigaPhil  Well, almost, as I wrote it from  */
/*                             examples I found on Internet. :-) */
/*                                                               */
/* A big thanks to Bernd Gollesch (on AmigaWorld.net) for having */
/* helped me to fix the script (signed integer issue) !!!        */
/*                                                               */
/* Do what you want with this script, but be warned that it can  */
/* be very slow (especially with long strings) !  If you need a  */
/* faster MD5 message digest algorithm, pick one of the binary   */
/* executable available on Aminet (http://www.aminet.net).       */

md5: procedure

   parse arg stuff

   numeric digits 11
   lenstuff=length(stuff)

   c0=myd2c(0)
   c1=myd2c(128)
   c1a=myd2c(255)
   c1111=c1a||c1a||c1a||c1a
   slen=length(stuff)*8
   slen512=slen//512

   /* pad message to multiple of 512 bits.  Last 2 words are 64 bit # bits in message*/
   if slen512=448 then  addme=512
   if slen512<448 then addme=448-slen512
   if slen512>448 then addme=960-slen512
   addwords=addme/8

   apad=c1||copies(c0,addwords-1)

   xlen=reverse(right(myd2c(lenstuff*8),4,c0))||c0||c0||c0||c0  /* 2**32 max bytes in message */

   /* NEWSTUFF is the message to be md5'ed */
   newstuff=stuff||apad||xlen

   /* starting values of registers */
   a ='67452301'x;
   b ='efcdab89'x;
   c ='98badcfe'x;
   d ='10325476'x;

   lennews=length(newstuff)/4

   /* loop through entire message */
   do i1 = 0 to ((lennews/16)-1)
   i16=i1*64
   do j=1 to 16
       j4=((j-1)*4)+1
       jj=i16+j4
       m.j=reverse(substr(newstuff,jj,4))
   end /* do */

   /* transform this block of 16 chars to 4 values. Save prior values first */
   aa=a;bb=b;cc=c;dd=d

   /* do 4 rounds, 16 operations per round (rounds differ in bit'ing functions */
   S11=7
   S12=12
   S13=17
   S14=22
   a=round1( a, b, c, d,   0 , S11, 3614090360); /* 1 */
   d=round1( d, a, b, c,   1 , S12, 3905402710); /* 2 */
   c=round1( c, d, a, b,   2 , S13,  606105819); /* 3 */
   b=round1( b, c, d, a,   3 , S14, 3250441966); /* 4 */
   a=round1( a, b, c, d,   4 , S11, 4118548399); /* 5 */
   d=round1( d, a, b, c,   5 , S12, 1200080426); /* 6 */
   c=round1( c, d, a, b,   6 , S13, 2821735955); /* 7 */
   b=round1( b, c, d, a,   7 , S14, 4249261313); /* 8 */
   a=round1( a, b, c, d,   8 , S11, 1770035416); /* 9 */
   d=round1( d, a, b, c,   9 , S12, 2336552879); /* 10 */
   c=round1( c, d, a, b,  10 , S13, 4294925233); /* 11 */
   b=round1( b, c, d, a,  11 , S14, 2304563134); /* 12 */
   a=round1( a, b, c, d,  12 , S11, 1804603682); /* 13 */
   d=round1( d, a, b, c,  13 , S12, 4254626195); /* 14 */
   c=round1( c, d, a, b,  14 , S13, 2792965006); /* 15 */
   b=round1( b, c, d, a,  15 , S14, 1236535329); /* 16 */

   /* Round 2 */
   S21=5
   S22=9
   S23=14
   S24=20
   a= round2( a, b, c, d,   1 , S21, 4129170786); /* 17 */
   d= round2( d, a, b, c,   6 , S22, 3225465664); /* 18 */
   c=  round2( c, d, a, b,  11 , S23,  643717713); /* 19 */
   b=  round2( b, c, d, a,   0 , S24, 3921069994); /* 20 */
   a=  round2( a, b, c, d,   5 , S21, 3593408605); /* 21 */
   d=  round2( d, a, b, c,  10 , S22,   38016083); /* 22 */
   c=  round2( c, d, a, b,  15 , S23, 3634488961); /* 23 */
   b= round2( b, c, d, a,   4 , S24, 3889429448); /* 24 */
   a= round2( a, b, c, d,   9 , S21,  568446438); /* 25 */
   d= round2( d, a, b, c,  14 , S22, 3275163606); /* 26 */
   c=  round2( c, d, a, b,   3 , S23, 4107603335); /* 27 */
   b=  round2( b, c, d, a,   8 , S24, 1163531501); /* 28 */
   a=  round2( a, b, c, d,  13 , S21, 2850285829); /* 29 */
   d=  round2( d, a, b, c,   2 , S22, 4243563512); /* 30 */
   c=  round2( c, d, a, b,   7 , S23, 1735328473); /* 31 */
   b= round2( b, c, d, a,  12 , S24, 2368359562); /* 32 */

   /* Round 3 */
   S31= 4
   S32= 11
   S33= 16
   S34= 23
   a= round3( a, b, c, d,   5 , S31, 4294588738); /* 33 */
   d=  round3( d, a, b, c,   8 , S32, 2272392833); /* 34 */
   c=  round3( c, d, a, b,  11 , S33, 1839030562); /* 35 */
   b=  round3( b, c, d, a,  14 , S34, 4259657740); /* 36 */
   a=  round3( a, b, c, d,   1 , S31, 2763975236); /* 37 */
   d=  round3( d, a, b, c,   4 , S32, 1272893353); /* 38 */
   c=  round3( c, d, a, b,   7 , S33, 4139469664); /* 39 */
   b=  round3( b, c, d, a,  10 , S34, 3200236656); /* 40 */
   a=  round3( a, b, c, d,  13 , S31,  681279174); /* 41 */
   d=  round3( d, a, b, c,   0 , S32, 3936430074); /* 42 */
   c=  round3( c, d, a, b,   3 , S33, 3572445317); /* 43 */
   b=  round3( b, c, d, a,   6 , S34,   76029189); /* 44 */
   a=  round3( a, b, c, d,   9 , S31, 3654602809); /* 45 */
   d=  round3( d, a, b, c,  12 , S32, 3873151461); /* 46 */
   c=  round3( c, d, a, b,  15 , S33,  530742520); /* 47 */
   b=  round3( b, c, d, a,   2 , S34, 3299628645); /* 48 */

   /* Round 4 */
   S41=6
   S42=10
   S43=15
   s44=21
   a=round4( a, b, c, d,   0 , S41, 4096336452); /* 49 */
   d=round4( d, a, b, c,   7 , S42, 1126891415); /* 50 */
   c=round4( c, d, a, b,  14 , S43, 2878612391); /* 51 */
   b=round4( b, c, d, a,   5 , s44, 4237533241); /* 52 */
   a=round4( a, b, c, d,  12 , S41, 1700485571); /* 53 */
   d=round4( d, a, b, c,   3 , S42, 2399980690); /* 54 */
   c=round4( c, d, a, b,  10 , S43, 4293915773); /* 55 */
   b=round4( b, c, d, a,   1 , s44,  2240044497); /* 56 */
   a=round4( a, b, c, d,   8 , S41, 1873313359); /* 57 */
   d=round4( d, a, b, c,  15 , S42, 4264355552); /* 58 */
   c=round4( c, d, a, b,   6 , S43, 2734768916); /* 59 */
   b=round4( b, c, d, a,  13 , s44, 1309151649); /* 60 */
   a=round4( a, b, c, d,   4 , S41, 4149444226); /* 61 */
   d=round4( d, a, b, c,  11 , S42, 3174756917); /* 62 */
   c=round4( c, d, a, b,   2 , S43,  718787259); /* 63 */
   b=round4( b, c, d, a,   9 , s44, 3951481745); /* 64 */


   a=m32add(aa,a) ; b=m32add(bb,b) ; c=m32add(cc,c) ; d=m32add(dd,d)

   end

   aa=c2x(reverse(a))||c2x(reverse(b))||c2x(reverse(C))||c2x(reverse(D))



   /*--- return MD5 ---------------------------------------------------------*/
   return translate(aa,'abcdef','ABCDEF')

/*===========================================================================*/
round1: procedure expose m. c1111 c0
/*===========================================================================*/
   parse arg a1,b1,c1,d1,kth,shift,sini
   kth=kth+1
   t1=myc2d(a1)+myc2d(f(b1,c1,d1))+ myc2d(m.kth) + sini
   t1a=right(myd2c(t1),4,c0)
   t2=rotleft(t1a,shift)
   t3=m32add(t2,b1)
   return t3

/*===========================================================================*/
round2: procedure expose m. c1111 c0
/*===========================================================================*/
   parse arg a1,b1,c1,d1,kth,shift,sini
   kth=kth+1
   t1=myc2d(a1)+myc2d(g(b1,c1,d1))+ myc2d(m.kth) + sini
   t1a=right(myd2c(t1),4,c0)
   t2=rotleft(t1a,shift)
   t3=m32add(t2,b1)
   return t3

/*===========================================================================*/
round3: procedure expose m. c1111 c0
/*===========================================================================*/
   parse arg a1,b1,c1,d1,kth,shift,sini
   kth=kth+1
   t1=myc2d(a1)+myc2d(h(b1,c1,d1))+ myc2d(m.kth) + sini
   t1a=right(myd2c(t1),4,c0)
   t2=rotleft(t1a,shift)
   t3=m32add(t2,b1)
   return t3

/*===========================================================================*/
round4: procedure expose m. c1111 c0
/*===========================================================================*/
   parse arg a1,b1,c1,d1,kth,shift,sini
   kth=kth+1
   t1=myc2d(a1)+myc2d(i(b1,c1,d1))+ myc2d(m.kth) + sini
   t1a=right(myd2c(t1),4,c0)
   t2=rotleft(t1a,shift)
   t3=m32add(t2,b1)
   return t3

/*===========================================================================*/
m32add: procedure expose c0
/* add to "char" numbers, modulo 2**32, return as char                       */
/*===========================================================================*/
   parse arg v1,v2
   t1=myc2d(v1)+myc2d(v2)
   t2=myd2c(t1)
   t3=right(t2,4,c0)
   return t3



/*===========================================================================*/
f: procedure expose c1111
/* F(x, y, z) == (((x) & (y)) | ((~x) & (z)))                                */
/*===========================================================================*/
   parse arg x,y,z
   t1=bitand(x,y)
   notx=bitxor(x,c1111)
   t2=bitand(notx,z)
   return bitor(t1,t2)


/*===========================================================================*/
g: procedure expose c1111
/* G(x, y, z) == (((x) & (z)) | ((y) & (~z)))*/
/*===========================================================================*/
   parse arg x,y,z
   t1=bitand(x,z)
   notz=bitxor(z,c1111)
   t2=bitand(y,notz)
   return bitor(t1,t2)

/*===========================================================================*/
h: procedure
/* H(x, y, z) == ((x) ^ (y) ^ (z)) */
/*===========================================================================*/
   parse arg x,y,z
   t1=bitxor(x,y)
   return bitxor(t1,z)

/*===========================================================================*/
i: procedure expose c1111
/* I(x, y, z) == ((y) ^ ((x) | (~z))) */
/*===========================================================================*/
   parse arg x,y,z
   notz=bitxor(z,c1111)
   t2=bitor(x,notz)
   return bitxor(y,t2)

/*===========================================================================*/
rotleft: procedure
/* bit rotate to the left by s positions                                     */
/*===========================================================================*/
   parse arg achar,s
   if s=0 then return achar

   bits=myx2b(c2x(achar))
   lb=length(bits)
   t1=left(bits,s)
   t2=bits||t1
   yib=right(t2,lb)
   return x2c(myb2x(yib))

/*===========================================================================*/
myc2d: procedure expose c0
/* c2d() replacement to "fix" signed integer                                 */
/*===========================================================================*/
parse arg val
val = right(val, 4, c0)
val_high = left(val, 2)
val_low = right(val, 2)
res = c2d(val_high)*65536 + c2d(val_low)
return res

/*===========================================================================*/
myd2c: procedure expose c0
/* d2c() replacement to "fix" signed integer                                 */
/*===========================================================================*/
parse arg val
if val > 2147483647 then
res = right(d2c(val%65536),2,c0) || right(d2c(val//65536),2,c0)
else
res=d2c(val)
return res

/*===========================================================================*/
myx2b: procedure
/* implement x2b() function if missing (like in ARexx, Rexx for Amiga)       */
/*===========================================================================*/
parse arg val
parse version rexxver
if left(rexxver,5) = 'ARexx' then return c2b(x2c(val))
return x2b(val)

/*===========================================================================*/
myb2x: procedure
/* implement b2x() function if missing (like in ARexx, Rexx for Amiga)       */
/*===========================================================================*/
parse arg val
parse version rexxver
if left(rexxver,5) = 'ARexx' then return c2x(b2c(val))
return b2x(val)

randomString: procedure
  /* Generate a random key */
  a=random(,,time("s"))
  r1 = random(0,9)
  r2 = random(0,9)
  r3 = random(0,9)
  r4 = random(0,9)
  r5 = random(0,9)
  r6 = random(0,9)

  /* Assemble the Token Request URL */
  tkey=r1 || r2 || r3 || r4 || r5 || r6
return tkey

/**************************************************************************/

CHECK:
  if ARG() & ARG(1)~="###PANIC" then return ARG(1)
  getcarrier
  if result="TRUE" then do
    if ARG() then return ARG(1)
    else return
  end
  logentry "Lost Carrier!!"
  bufferflush
  exit

SYNTAX:
ERROR:
IOERR:
  e1="n1 Error: "rc" ("errortext(rc)")"
  e2="  Line: "left(sigl,4)"File:"
  c="`"fp", "ver"'"
  e2=e2" "c
  tr e1
  tr e2
  e=strip(translate(sourceline(sigl),"\{",""))
  do while e~=""
    e3="Source: "left(e,37)
    tr e3
    e=substr(e,38)
    end
  bufferflush
  exit
/**************************************************************************\
\*************************** -X-caliber BBS telnet://bbs.aholix.net:6800 **/